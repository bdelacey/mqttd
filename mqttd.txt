-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/dustin/mqttd#readme</a>
@package mqttd
@version 0.1.0.0

module MQTTD.Config
data Config
Config :: Bool -> Map ByteString User -> [Listener] -> ListenerOptions -> Config
[_confDebug] :: Config -> Bool
[_confUsers] :: Config -> Map ByteString User
[_confListeners] :: Config -> [Listener]
[_confDefaults] :: Config -> ListenerOptions
data User
User :: ByteString -> ByteString -> [ACL] -> User
data ACL
Allow :: Filter -> ACL
Deny :: Filter -> ACL
data Listener
MQTTListener :: HostPreference -> PortNumber -> ListenerOptions -> Listener
MQTTSListener :: HostPreference -> PortNumber -> FilePath -> FilePath -> ListenerOptions -> Listener
WSListener :: ListenAddress -> PortNumber -> ListenerOptions -> Listener
data ListenerOptions
ListenerOptions :: Maybe Bool -> ListenerOptions
[_optAllowAnonymous] :: ListenerOptions -> Maybe Bool
listenerOpts :: Lens' Listener ListenerOptions
parseConfFile :: String -> IO Config
instance GHC.Show.Show MQTTD.Config.Section
instance GHC.Classes.Eq MQTTD.Config.Config
instance GHC.Show.Show MQTTD.Config.Config
instance GHC.Classes.Eq MQTTD.Config.Listener
instance GHC.Show.Show MQTTD.Config.Listener
instance GHC.Show.Show MQTTD.Config.ListenerOptions
instance GHC.Classes.Eq MQTTD.Config.ListenerOptions
instance GHC.Classes.Eq MQTTD.Config.User
instance GHC.Show.Show MQTTD.Config.User
instance GHC.Classes.Eq MQTTD.Config.ACL
instance GHC.Show.Show MQTTD.Config.ACL
instance GHC.Base.Semigroup MQTTD.Config.ListenerOptions
instance GHC.Base.Monoid MQTTD.Config.ListenerOptions

module MQTTD.SubTree

-- | MQTT Topic Subscription tree.
data SubTree a

-- | Modify a subscription for the given filter.
--   
--   This will create structure along the path and will not clean up any
--   unused structure.
modify :: Monoid a => Filter -> (a -> a) -> SubTree a -> SubTree a

-- | Add a value at the given filter path.
add :: Monoid a => Filter -> a -> SubTree a -> SubTree a

-- | Find subscribers of a given topic.
find :: Monoid a => Topic -> SubTree a -> a

-- | Find all matching subscribers
findMap :: Monoid m => Topic -> (a -> m) -> SubTree a -> m

-- | flatten a SubTree to a list of (topic,a) pairs. Note this will return
--   <a>mempty</a> in paths along subscription paths.
flatten :: SubTree a -> [(Filter, a)]

-- | Construct a SubTree from a list of filters and subscribers.
fromList :: Monoid a => [(Filter, a)] -> SubTree a
instance GHC.Classes.Eq a => GHC.Classes.Eq (MQTTD.SubTree.SubTree a)
instance GHC.Show.Show a => GHC.Show.Show (MQTTD.SubTree.SubTree a)
instance GHC.Base.Functor MQTTD.SubTree.SubTree
instance Data.Foldable.Foldable MQTTD.SubTree.SubTree
instance Data.Traversable.Traversable MQTTD.SubTree.SubTree
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (MQTTD.SubTree.SubTree a)
instance GHC.Base.Monoid a => GHC.Base.Monoid (MQTTD.SubTree.SubTree a)

module MQTTD.Util
textToBL :: Text -> ByteString
blToText :: ByteString -> Text
tshow :: Show a => a -> Text
justM :: Monad m => (a -> m ()) -> Maybe a -> m ()

module Scheduler
type TimedQueue a = Map UTCTime [a]
add :: Ord a => UTCTime -> a -> TimedQueue a -> TimedQueue a
ready :: UTCTime -> TimedQueue a -> ([a], TimedQueue a)
next :: TimedQueue a -> Maybe UTCTime
newtype QueueRunner a
QueueRunner :: TVar (TimedQueue a) -> QueueRunner a
[_tq] :: QueueRunner a -> TVar (TimedQueue a)
newRunner :: MonadIO m => m (QueueRunner a)
enqueue :: (Ord a, MonadIO m) => UTCTime -> a -> QueueRunner a -> m ()

-- | Run forever.
run :: (MonadLogger m, MonadIO m) => (a -> m ()) -> QueueRunner a -> m ()

-- | Block until an item might be ready and then run (and remove) all ready
--   items. This will sometimes run 0 items. It shouldn't ever run any
--   items that are scheduled for the future, and it shouldn't forget any
--   items that are ready.
runOnce :: (MonadLogger m, MonadIO m) => (a -> m ()) -> QueueRunner a -> m ()
diffTimeToMicros :: NominalDiffTime -> Int

module MQTTD.Retention
data Retained
Retained :: UTCTime -> Maybe UTCTime -> PublishRequest -> Retained
[_retainTS] :: Retained -> UTCTime
[_retainExp] :: Retained -> Maybe UTCTime
[_retainMsg] :: Retained -> PublishRequest
data Persistence
Persistence :: TVar (Map ByteString Retained) -> QueueRunner ByteString -> Persistence
[_store] :: Persistence -> TVar (Map ByteString Retained)
[_qrunner] :: Persistence -> QueueRunner ByteString
newPersistence :: MonadIO m => m Persistence
cleanPersistence :: (MonadLogger m, MonadUnliftIO m) => Persistence -> m ()
retain :: (MonadLogger m, MonadIO m) => PublishRequest -> Persistence -> m ()
matchRetained :: MonadIO m => Persistence -> Filter -> m [PublishRequest]
instance GHC.Show.Show MQTTD.Retention.Retained

module MQTTD
data MQTTException
MQTTPingTimeout :: MQTTException
MQTTDuplicate :: MQTTException
type PktQueue = TBQueue MQTTPkt
type ClientID = Int
data ConnectedClient
ConnectedClient :: ConnectRequest -> ThreadId -> ClientID -> TVar (Map Word16 ByteString) -> TVar (Map ByteString Word16) -> TVar Word16 -> ConnectedClient
[_clientConnReq] :: ConnectedClient -> ConnectRequest
[_clientThread] :: ConnectedClient -> ThreadId
[_clientID] :: ConnectedClient -> ClientID
[_clientAliasIn] :: ConnectedClient -> TVar (Map Word16 ByteString)
[_clientAliasOut] :: ConnectedClient -> TVar (Map ByteString Word16)
[_clientALeft] :: ConnectedClient -> TVar Word16
clientThread :: Lens' ConnectedClient ThreadId
clientID :: Lens' ConnectedClient ClientID
clientConnReq :: Lens' ConnectedClient ConnectRequest
clientAliasOut :: Lens' ConnectedClient (TVar (Map ByteString Word16))
clientAliasIn :: Lens' ConnectedClient (TVar (Map Word16 ByteString))
clientALeft :: Lens' ConnectedClient (TVar Word16)
data Session
Session :: ByteString -> [ACL] -> Maybe ConnectedClient -> PktQueue -> TVar (Map PktID PublishRequest) -> TVar (Map Filter SubOptions) -> Maybe UTCTime -> Maybe LastWill -> Session
[_sessionID] :: Session -> ByteString
[_sessionACL] :: Session -> [ACL]
[_sessionClient] :: Session -> Maybe ConnectedClient
[_sessionChan] :: Session -> PktQueue
[_sessionQP] :: Session -> TVar (Map PktID PublishRequest)
[_sessionSubs] :: Session -> TVar (Map Filter SubOptions)
[_sessionExpires] :: Session -> Maybe UTCTime
[_sessionWill] :: Session -> Maybe LastWill
sessionWill :: Lens' Session (Maybe LastWill)
sessionSubs :: Lens' Session (TVar (Map Filter SubOptions))
sessionQP :: Lens' Session (TVar (Map PktID PublishRequest))
sessionID :: Lens' Session ByteString
sessionExpires :: Lens' Session (Maybe UTCTime)
sessionClient :: Lens' Session (Maybe ConnectedClient)
sessionChan :: Lens' Session PktQueue
sessionACL :: Lens' Session [ACL]
data Authorizer
Authorizer :: Map ByteString User -> Bool -> Authorizer
[_authUsers] :: Authorizer -> Map ByteString User
[_authAnon] :: Authorizer -> Bool
authUsers :: Lens' Authorizer (Map ByteString User)
authAnon :: Lens' Authorizer Bool
data Env
Env :: TVar (Map ByteString Session) -> TVar Word16 -> TVar ClientID -> QueueRunner ByteString -> Persistence -> Authorizer -> Env
[sessions] :: Env -> TVar (Map ByteString Session)
[lastPktID] :: Env -> TVar Word16
[clientIDGen] :: Env -> TVar ClientID
[queueRunner] :: Env -> QueueRunner ByteString
[persistence] :: Env -> Persistence
[authorizer] :: Env -> Authorizer
newtype MQTTD m a
MQTTD :: ReaderT Env m a -> MQTTD m a
[runMQTTD] :: MQTTD m a -> ReaderT Env m a
runIO :: (MonadIO m, MonadLogger m) => Env -> MQTTD m a -> m a
newEnv :: MonadIO m => Authorizer -> m Env
modifyAuthorizer :: Monad m => (Authorizer -> Authorizer) -> MQTTD m a -> MQTTD m a
seconds :: Num p => p -> p
nextID :: MonadIO m => MQTTD m Int
type PublishConstraint m = (MonadLogger m, MonadFail m, MonadMask m, MonadUnliftIO m, MonadIO m)
sessionCleanup :: PublishConstraint m => MQTTD m ()
persistenceCleanup :: (MonadUnliftIO m, MonadLogger m) => MQTTD m ()
resolveAliasIn :: MonadIO m => Session -> PublishRequest -> m PublishRequest
findSubs :: MonadIO m => Topic -> MQTTD m [(Session, SubOptions)]
subscribe :: PublishConstraint m => Session -> SubscribeRequest -> MQTTD m [Either SubErr QoS]
unsubscribe :: MonadIO m => Session -> [ByteString] -> MQTTD m [UnsubStatus]
modifySession :: MonadIO m => ByteString -> (Session -> Maybe Session) -> MQTTD m ()
registerClient :: MonadIO m => ConnectRequest -> ClientID -> ThreadId -> MQTTD m (Session, SessionReuse)
expireSession :: PublishConstraint m => ByteString -> MQTTD m ()
defaultSessionExp :: NominalDiffTime
unregisterClient :: (MonadLogger m, MonadMask m, MonadFail m, MonadUnliftIO m, MonadIO m) => ByteString -> ClientID -> MQTTD m ()
sendPacket :: PktQueue -> MQTTPkt -> STM Bool
sendPacket_ :: PktQueue -> MQTTPkt -> STM ()
sendPacketIO :: MonadIO m => PktQueue -> MQTTPkt -> m Bool
sendPacketIO_ :: MonadIO m => PktQueue -> MQTTPkt -> m ()
nextPktID :: TVar Word16 -> STM Word16
broadcast :: PublishConstraint m => Maybe ByteString -> PublishRequest -> MQTTD m ()
publish :: PublishConstraint m => Session -> PublishRequest -> MQTTD m ()
aliasOut :: ConnectedClient -> PublishRequest -> STM PublishRequest
authTopic :: Topic -> [ACL] -> Either String ()
dispatch :: PublishConstraint m => Session -> MQTTPkt -> MQTTD m ()
instance Control.Monad.Fail.MonadFail m => Control.Monad.Fail.MonadFail (MQTTD.MQTTD m)
instance GHC.Base.Monad m => Control.Monad.Reader.Class.MonadReader MQTTD.Env (MQTTD.MQTTD m)
instance Control.Monad.Catch.MonadMask m => Control.Monad.Catch.MonadMask (MQTTD.MQTTD m)
instance Control.Monad.Catch.MonadThrow m => Control.Monad.Catch.MonadThrow (MQTTD.MQTTD m)
instance Control.Monad.Catch.MonadCatch m => Control.Monad.Catch.MonadCatch (MQTTD.MQTTD m)
instance Control.Monad.Logger.MonadLogger m => Control.Monad.Logger.MonadLogger (MQTTD.MQTTD m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (MQTTD.MQTTD m)
instance GHC.Base.Monad m => GHC.Base.Monad (MQTTD.MQTTD m)
instance GHC.Base.Functor m => GHC.Base.Functor (MQTTD.MQTTD m)
instance GHC.Base.Applicative m => GHC.Base.Applicative (MQTTD.MQTTD m)
instance Control.Monad.IO.Unlift.MonadUnliftIO m => Control.Monad.IO.Unlift.MonadUnliftIO (MQTTD.MQTTD m)
instance GHC.Show.Show MQTTD.Authorizer
instance GHC.Show.Show MQTTD.ConnectedClient
instance GHC.Show.Show MQTTD.MQTTException
instance GHC.Exception.Type.Exception MQTTD.MQTTException

module MQTTD.Conduit
type MQTTConduit m = (ConduitT () ByteString (MQTTD m) (), ConduitT ByteString Void (MQTTD m) ())
authorize :: (MonadFail m, Monad m) => ConnectRequest -> MQTTD m (Either String ())
runMQTTDConduit :: forall m. PublishConstraint m => MQTTConduit m -> MQTTD m ()
webSocketsApp :: PublishConstraint m => PendingConnection -> MQTTD m ()
tcpApp :: PublishConstraint m => AppData -> MQTTD m ()
